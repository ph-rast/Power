##         Title: Power to detect change
##    Created at: 09-12.2012
## Last modified: 11-07-2014
##        Author: Philippe Rast <prast@uvic.ca>
##          Data: Data is generated by random.gen() function
##       Summary: Generate samples with correlated Factors and correlated
##                error terms. Wald and LR statistics are provided
##                for the slope variances and covariances.
##  Requirements: Following packages are needed:
##                'OpenMx' (>= version 1.2.3) cf. http://openmx.psyc.virginia.edu/
##                'snowfall' for parallel computing
##      Citation: Rast, P., & Hofer, S. M. (2014). Longitudinal design considerations to
##                optimize power to detect variances and covariances among rates of change:
##                Simulation results based on actual longitudinal studies.
##                Psychological Methods, 19(1), 133–154. doi:10.1037/a0034524

## ---------------------------------------------------------------------- ##

## NOTE: This script is being called - no need to edit.
## Population parameters are provided in calling script
## e.g. by MC_BlkMir.R

## check for presence of required packages - if not present, pkg will be pulled and installed
if (!'OpenMx' %in% installed.packages()) source('http://openmx.psyc.virginia.edu/getOpenMx.R')
if (!'snowfall' %in% installed.packages()) install.packages('snowfall')

#######################################################################################
# Number of waves
W <- length(Ws) # W=Waves
## Number of different samples with different N
Ncond=length(Ns) 

##-----------------------------------------------------------------------##
## Create symmetric matrix (covariance matrix) for sampling from mvrnorm ##
nVar <- length(mu)
SigmaDep <- matrix(0, ncol=nVar, nrow=nVar)
SigmaDep[lower.tri(SigmaDep)] <- obs.covs
SigmaDep <- SigmaDep+t(SigmaDep)
diag(SigmaDep) <- sigdiag
##                            END SigmDep                                ##
##-----------------------------------------------------------------------##

##------------------------------------------------------------##
##    Functions to be called in the MC simulation             ##

##----------------------------------------##
##            Population model            ##
## Generate sample of size N
## Residual covariance included between eg. x1<->y1 x2<->y2 x3<->y3 x4<->y4
random.gen <- function(N, mu, SigmaDep, Ws, resvar1, resvar2, rescov){
  require(MASS)
  ZDep <- mvrnorm(n=N, mu=mu, Sigma=SigmaDep)
  time=array(Ws)
  W=length(Ws)
  ## draw residuals given rescov and resvar
 err <- matrix(0, ncol=2*W,nrow=2*W)
   diag(err) <- c(rep(resvar1, W), rep(resvar2, W))
   diag(err[(W+1):(2*W),1:W]) <- rep(rescov,W)
   diag(err[1:W,(W+1):(2*W)]) <- rep(rescov,W)
 resid <- mvrnorm(N, rep(0, 2*W), Sigma=err)
  ## Generate observed values given the linear model. 
  mcsample <- cbind(ZDep[,1]+ZDep[,2]%*%t(time), ZDep[,3]+ZDep[,4]%*%t(time))+resid
  mcsample <- data.frame(mcsample)
  names(mcsample) <- c(paste(rep('Y', W), c(1:W), sep=""),paste(rep('X', W), c(1:W), sep=""))
  cov.mcsample <- var(mcsample)
  ## Make sure matrix is positive definite
  cov.mcsample <- t(chol(cov.mcsample))%*%chol(cov.mcsample)
  m.mcsample <- colMeans(mcsample)
  return(list(cov.mcsample,m.mcsample))
}

## return estimates and compute Wald statistic for each estimate
getStats <- function(model) {
        retval <- c(model@output$status[[1]],
                    max(abs(model@output$gradient)),
                    model@output$estimate)
           waldZ <-  model@output$estimate/c(model@output$standardErrors)
           names(waldZ) <-  paste('waldZ', names(waldZ), sep=".")
            cil <-  model@output$estimate-1.96*c(model@output$standardErrors)
            ciu <-  model@output$estimate+1.96*c(model@output$standardErrors)        
            names(cil) <- paste('cil', names(cil), sep=".")
            names(ciu) <- paste('ciu', names(ciu), sep=".")      
        retval <- c(retval, waldZ, cil, ciu)
        return(retval)
}

##----------------------------------------##
##      Generate latent GCM in openMx     ##
require(OpenMx)

## instantiate MxModel
## ------------------- Definition of bivariate GCM ------------------------ ##
# data is generated. openMx needs data in the 'observed' statement of mxModel
N=200
mcdata <- random.gen(N, mu, SigmaDep, Ws, resvar1, resvar2, rescov)
manifests <- names(mcdata[[2]])

template <-mxModel("bivgcm",
              type="RAM",
              manifestVars=manifests,
              latentVars=c("L1","S1","L2","S2"),
              # if N and r are small, numerical precision is an issue: Solve with round
              mxData(observed=round(mcdata[[1]],decPl), 
                     type="cov",
                     numObs=N,
                     means=mcdata[[2]]),                                
              # latent variances and covariance
               mxPath(from = c("L1","S1","L2","S2"),
                      arrows = 2, connect = "unique.bivariate",
                      values = SigmaDep[lower.tri(SigmaDep)],
                      free = TRUE, labels = c("cL1S1", "cL1L2", "cL1S2",
                                                       "cS1L2", "cS1S2",
                                                                "cL2S2")),
               mxPath(from = c("L1","S1","L2","S2"),
                      values = diag(SigmaDep),
                      arrows = 2, connect = "single",
                      lbound=c(0,0,0,0),
                      free = TRUE, labels = c("varL1", "varS1", "varL2", "varS2")),
              # intercept loadings Y                   
              mxPath(
                     from="L1",
                     to=manifests[1:W],
                     arrows=1,
                     free=FALSE,
                     values=rep(1, W)
                     ),
             # intercept loadings X
              mxPath(
                     from="L2",
                     to=manifests[(W+1):(2*W)],
                     arrows=1,
                     free=FALSE,
                     values=rep(1, W)
                     ),                  
              # slope loadings Y
              mxPath(
                     from="S1",
                     to=manifests[1:W],
                     arrows=1,
                     free=FALSE,
                     values=Ws
                     ),
              # slope loadings X
              mxPath(
                     from="S2",
                     to=manifests[(W+1):(2*W)],
                     arrows=1,
                     free=FALSE,
                     values=Ws
                     ),                  
              # manifest means
              mxPath(from="one",
                     to=manifests,
                     arrows=1,
                     free=FALSE,
                     values=rep(0,W)
                     ),
              # latent means
              mxPath(from="one",
                     to=c("L1", "S1", "L2", "S2"),
                     arrows=1,
                     free=TRUE,
                     values=mu,
                     labels=c("meanL1", "meanS1", "meanL2", "meanS2")
                     ),
              # residual variances
              mxPath(
                     from=manifests, 
                     arrows=2,
                     free=TRUE,
                     values = c(rep(resvar1, W), rep(resvar2, W)),
                     labels= c(rep('resY', W), rep('resX', W)), 
                     lbound=rep(0, 2*W))
                   ,                   
              # Residual covariances
               mxPath(from=manifests[1:W],
                      to=manifests[(W+1):(2*W)],
                      arrows=2,
                      free=TRUE,
                      values=rep(rescov, W),
                      labels=rep('resXYcov', W)
                     )     
) 
##                    END GCM Definition                         ##
## --------------------------------------------------------------##

## Generate openMx models
createNewModel <- function(index){
     mcdata <- random.gen(N, mu, SigmaDep, Ws, resvar1, resvar2, rescov)
        model <-  mxModel(template,
                          independent=TRUE,
                          name=paste("bivgcm", index, sep=""),
                          data <- mxData(observed=round(mcdata[[1]],9),
                                         type="cov", numObs=N,
                                         means=mcdata[[2]]))
                 return(model)
        }

## Obtain LR ratio for Chi² test
## faster way to get at LR than with mxCompare
### Covariance
  getLRcov <- function(index){
    lL0 <- results@submodels[[index]]@output$Minus2LogLikelihood[1]
    lLcov <- modrest.r@submodels[[index]]@output$Minus2LogLikelihood[1]
    LR.sig.r <- 1-pchisq(lLcov-lL0, df=1)
    return(LR.sig.r)
  }
### Variance S1
  getLRS1 <- function(index){
    lL0 <- results@submodels[[index]]@output$Minus2LogLikelihood[1]
    lLS1 <- modrest.s1@submodels[[index]]@output$Minus2LogLikelihood[1]
    LR.sig.S1 <- 1-pchisq(lLS1-lL0, df=4)
    return(LR.sig.S1)
  }
### Variance S2
  getLRS2 <- function(index){
    lL0 <- results@submodels[[index]]@output$Minus2LogLikelihood[1]
    lLS2 <- modrest.s2@submodels[[index]]@output$Minus2LogLikelihood[1]
    LR.sig.S2 <- 1-pchisq(lLS2-lL0, df=4)
    return(LR.sig.S2)
  }


##################################
##       Run simulation         ##
##################################

##----------------------------------------##
##         CPU parameters                 ##
##  Simlation will be run parallel on given amount of CPUs using snowfall library
## set up functions for snowfall:
require(snowfall)
sfInit(parallel=T, cpus=nCPUS)
sfLibrary(OpenMx)
sfLibrary(MASS)


s=sqrt(sigdiag[2]*sigdiag[4]) # sqrt of S1 variance and S2 variance
mcResults <- matrix(0, nrow=Ncond*length(r), ncol=12) # Results
sfExport('random.gen','mu','Ws','resvar1','resvar2','rescov','template')

## outer loop
for(k in 1:length(r)){
  obs.covs[5] <- r[k]*s
  ## Create symmetric matrix (covariance matrix)
  nVar <- length(mu)
  SigmaDep <- matrix(0, ncol=nVar, nrow=nVar)
  SigmaDep[lower.tri(SigmaDep)] <- obs.covs
  SigmaDep <- SigmaDep+t(SigmaDep)
  diag(SigmaDep) <- sigdiag
  ## set matrix here, in case mxRun encounters problem and skips loop,
  ## then mcResults2 needs to be refreshed with every change in N to sfExport
  mcResults2 <- matrix(0, nrow=Ncond, ncol=12) # Results container
## inner loop
for(i in 1:Ncond){  
  N=Ns[i]
  sfExport('N', 'SigmaDep')
## Genereate nReps models 
  mySubs <- sfLapply(1:nReps, createNewModel)
  topModel <- mxModel("Top")
  topModel@submodels <- mySubs
#-WALD
  ## Run models for Wald statistics
  mod <- try(mxRun(topModel, suppressWarnings=TRUE, unsafe=TRUE))
  ## check if mxRun encountered a problem. If this is the case
  ## all results are dumped for the current N  value and NA's will be written in the mcResults matrix
  ## 'next' advances to next index in loop.
  if (inherits(mod, 'try-error')) next else results=mod  
## Copy Model 0 and restrict slope covariances to zero
  restricted.r <- mySubs
  for(l in 1:nReps){
    restricted.r[[l]]@matrices$S@values['S2','S1'] <- 0
    restricted.r[[l]]@matrices$S@values['S1','S2'] <- 0
    restricted.r[[l]]@matrices$S@free['S2','S1'] <- FALSE
    restricted.r[[l]]@matrices$S@free['S1','S2'] <- FALSE}
#-COVARIANCES
  topCovModel <- mxModel("TopCov")
  topCovModel <- mxOption(topCovModel, "Calculate Hessian", "No") #optimize for speed
  topCovModel <- mxOption(topCovModel, "Standard Errors", "No") #optimize for speed
  topCovModel@submodels <- restricted.r
  modrest.r <- try(mxRun(topCovModel, suppressWarnings=TRUE, unsafe=TRUE))
  if (inherits(modrest.r, 'try-error')) next else LR.sig.r=sapply(1:nReps, getLRcov)
## Copy unrestricted model and set variances and covariances wit S1 to zero
  restricted.s1 <- mySubs
  for(l in 1:nReps){
  # note, ALL coavariances with S1 need to be set to 0
    restricted.s1[[l]]@matrices$S@values['S1' , ] <- 0
    restricted.s1[[l]]@matrices$S@values[ , 'S1'] <- 0
    restricted.s1[[l]]@matrices$S@free['S1' , ] <- FALSE
    restricted.s1[[l]]@matrices$S@free[ , 'S1'] <- FALSE}
  topS1Model <- mxModel("TopS1")
  topS1Model <- mxOption(topS1Model, "Calculate Hessian", "No")
  topS1Model <- mxOption(topS1Model, "Standard Errors", "No")
  topS1Model@submodels <- restricted.s1
  modrest.s1 <- try(mxRun(topS1Model, suppressWarnings=TRUE, unsafe=TRUE))
  if (inherits(modrest.s1, 'try-error')) next else LR.sig.s1=sapply(1:nReps, getLRS1) 
## Copy unrestricted model and set variances and covariances wit S2 to zero
   restricted.s2 <- mySubs
  for(l in 1:nReps){
  # note, ALL covariances with S2 need to be set to 0
    restricted.s2[[l]]@matrices$S@values['S2' , ] <- 0
    restricted.s2[[l]]@matrices$S@values[ , 'S2'] <- 0
    restricted.s2[[l]]@matrices$S@free['S2' , ] <- FALSE
    restricted.s2[[l]]@matrices$S@free[ , 'S2'] <- FALSE}
  topS2Model <- mxModel("TopS2")
  topS2Model <- mxOption(topS2Model, "Calculate Hessian", "No")
  topS2Model <- mxOption(topS2Model, "Standard Errors", "No")
  topS2Model@submodels <- restricted.s2
  modrest.s2 <- try(mxRun(topS2Model, suppressWarnings=TRUE, unsafe=TRUE))
  if (inherits(modrest.s2, 'try-error')) next else LR.sig.s2=sapply(1:nReps, getLRS2)   
  w=1
  while(length(getStats(results@submodels[[w]]))==1) w=w+1
  dn <- names(getStats(results@submodels[[w]]))
  dn[1:2] <- c('inform', 'maxAbsG')
  # Write results
  modelResults <- matrix(nrow=nReps, ncol=length(dn)) # All values of inerest go in here!
  for(j in 1:nReps){
      modelResults[j,] <-  getStats(results@submodels[[j]]) 
  }
  colnames(modelResults) <-  dn
  modelResults <- cbind(modelResults, cbind(LR.sig.r, LR.sig.s1, LR.sig.s2))
  # get rid of bad convergence results > 1 and of NaN's and of non-positive definit matirces =-1
  results2 <-    na.omit(data.frame(modelResults[which(modelResults[,1] <= 1 & modelResults[,1] != -1),]))
  ## Report N
  mcResults2[i,1] <- N
  ## Power: How often is value significant.
  ## Correlation:
  mcResults2[i,2] <- sum(ifelse(sign(r[k])*results2$waldZ.cS1S2>=1.96, 1, 0))/dim(results2)[1]
  mcResults2[i,3] <- sum(ifelse(results2$LR.sig.r<=0.05, 1, 0))/dim(results2)[1]  
  ### Coverage: how often is the pop value contained in the 95% estimate obs.covs[5]=SigmaDep[4,2]
  mcResults2[i,4] <- sum(ifelse(results2$cil.cS1S2 < SigmaDep[4,2] & results2$ciu.cS1S2 >SigmaDep[4,2], 1, 0))/dim(results2)[1]
  ## Variance S1:
  mcResults2[i,5] <- sum(ifelse(results2$waldZ.varS1>=1.96, 1, 0))/dim(results2)[1]
  mcResults2[i,6] <- sum(ifelse(results2$LR.sig.s1<=0.05, 1, 0))/dim(results2)[1]  
  ### Coverage S1:
  mcResults2[i,7] <- sum(ifelse(results2$cil.varS1<sigdiag[2] & results2$ciu.varS1>sigdiag[2], 1, 0))/dim(results2)[1]
  ## Variance S2:
  mcResults2[i,8] <- sum(ifelse(results2$waldZ.varS2>=1.96, 1, 0))/dim(results2)[1]
  mcResults2[i,9] <- sum(ifelse(results2$LR.sig.s2<=0.05, 1, 0))/dim(results2)[1]    
  ### Coverage S2:
  mcResults2[i,10] <- sum(ifelse(results2$cil.varS2<sigdiag[4] & results2$ciu.varS2>sigdiag[4], 1, 0))/dim(results2)[1]
  ## Valid samples
  mcResults2[i,11] <- dim(results2)[1]
  #save(mcResults2, file=paste(i, 'genRes.dat', sep="_"))  # uncomment to save interim result.
 }  
## Outer loop index
mcResults[(k-1)*Ncond+c(1:Ncond),] <-  mcResults2
mcResults[(k-1)*Ncond+c(1:Ncond),12] <-  rep(r[k], Ncond)
}



colnames(mcResults) <- c('N', 'PS1S2W','PS1S2LR', 'coverageS1S2', 'PS1W','PS1LR', 'coverageS1',
                         'PS2W','PS2LR', 'coverageS2','validSamp', 'r')
## Table with mc sampling results
mcResults <- data.frame(mcResults)

## Stop parallel processing
sfStop()
